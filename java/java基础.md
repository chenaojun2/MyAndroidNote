# java基础

### 面向对象编程的四大特性和含义

* 抽象：对现实世界进行概括，抽象成在计算机虚拟世界中有意义的实体

* 封装：将某事物的属性和行为包装到对象中，构成一个不可分割的实体。数据被保护在抽象数据类型的内部，尽可能的隐藏内部细节，只保留对外的接口。

* 继承：子类继承父类，不仅有父类原有可访问的方法和属性，还可以扩展方法属性

* 多态：允许不同对象，对同一消息可以做出不同的反应。

### String、StringBuffer、StringBuilder的区别

* String 是字符串常量，其余两者是变量。即String对象一创建后不可更改，后两者的对象是可更改。

* String、StringBuffer是线程安全的，StringBuilder是非线程安全的。String的线程安全是因为不可变，StringBuffer的线程安全是因为加锁。

* String适合少量字符串操作

* StringBuilder 适合单线程下进行复杂操作

* StringBuffer 适合多线程下的复杂操作

### String a = ""和String a = new String()的关系有何异同

* 第一种方法是直接复制，得到的是一个常量，存在于常量池。内容相同的字符串只会在常量池中存在一个。

* 第二种方法是实例化一个变量，数据存于堆内存中。每个实例对象都有自己的地址。

### 装箱、拆箱

装箱是指基础数据类型转换为包装器类型，拆箱是指包装器类型自动转换为基本数据类型。

### java异常机制

java异常机制按继承的层次结构，可以分成两大类Error和Exception

* Error: 错误，指程序无法恢复的异常状况，表示运行程序中较为严重的问题。发生于虚拟机自身、或者在虚拟机试图执行应用时，如Virtual MachineError（Java虚拟机运行错误）、NoClassDefFoundError（类定义错误）；属于不可查异常，即不强制程序员必须处理，即使不处理也不会出现语法错误。

* Exception：异常：指程序无法恢复的异常情况。表示程序本身可以处理的异常。

    RuntimeException(运行时异常)：由于程序自身问题导致的异常，常见的有空指针、数组越界。属于不可查异常。

    (非运行时异常)：由于程序外部问题引起的异常，这种异常属于可查异常，会强制程序员必须处理，不处理就会出现语法错误。

常见的异常处理机制

捕捉异常：由于系统自动抛出异常，然后try捕获异常->catch处理异常->finally 最终处理

抛出异常：在方法中将异常对象显性的抛出，之后就会延着调用层级向上抛出，交由调用它的方法处理。不处理就搞崩程序

自定义异常：继承Exception或子类

### 什么是内部类？有什么作用？静态内部类和非静态内部类的区别？

内部类就是定义在另一个类里面的类，它隐藏在外部类中，封装性更强，不允许除了外部类外的其他类引用它。

静态内部类是指被声明为static的内部类，可不依赖外部类实例化；而非静态内部类需要通过生成外部类来间接生成。

静态内部类只能访问外部类的静态成员变量和静态方法，而非静态内部类由于持有对外部类的引用，可以访问外部类的所用成员

### 重写和重载

重写方法必须满足下列条件

(1) 子类的方法的名称及参数必须和所覆盖的方法相同

(2) 子类的方法返回类型必须和所覆盖的方法相同

(3) 子类方法不能缩小所覆盖方法的访问权限

(4) 子类方法不能抛出比所覆盖方法更多的异常

重载方法必须满足下列条件

(1) 方法名必须相同

(2) 方法的参数可不相同

(3) 方法的返回类型和方法的修饰符可以不相同

### java类的初始化顺序

父类静态字段、父类静态代码块 
子类静态字段、子类静态代码块
父类成员变量、父类非静态代码块
子类成员变量、子类非静态代码块
父类构造函数、子类构造函数


## 集合

### Java集合框架中有哪些类？都有什么特点

可以将集合框架大致分为Collection和Map两种

Collection又可以继续分为Set、List、Queue

Set：代表无序、不可重复的集合，常见的类如HashSet、TreeSet。

List:代表有序、可重复的集合，常见的类如动态数组ArrayList、双向链表LinkedList、可变数组Vector

Map：代表具有映射关系的集合，Map遍历起来是无序

Queue:代表一种队列集合。

### ArrayList和LinkList的区别？

ArrayList的底层数据结构是数组，可用索引实现快速查找；是动态数组，相比于数组容量可实现动态增长。

LinkedList的底层结构是链表，增删速度快，是一个双向循环链表，也可以当作堆栈、队列、双端队列

### ArrayList和Vector的区别

ArrayList是非线程安全，建议在单线程的环境下使用，多线程使用Vector或者CopyOnWriteArrayList。默认初始容量为10，每次扩容为原来的1.5倍。

Vector使用了synchronized关键字，是线程安全的,比ArrayList的开销大，访问更慢；默认初始容量为10，每次扩容2倍。可以设置capacityIncrement来控制扩容倍数。


### HashSet和TreeSet的区别？

HashSet不能保证排列顺序，使用了Hash算法来存储集合中的元素，有良好的存取和查找性能；通过equal判断两个元素是否相等，并且两个元素的hashCode也相等。

TreeSet是SortedSet接口的实现类，和上面不同，这个是有序的。会根据元素的大小进行排序。采用红黑树的数据结构来存储集合元素；支持两种排序方法（自然排序，定制排序）定制排序通过Comparated接口中的compare（）比较两个元素之间的大小关系

### HashMap和HashTable

 HashMap基于AbstractMap类，实现了Map、Cloneable、Serializable接口；非线程安全。允许存在一个为null的key和任意个为null的value。采用链表散列的结构，数组与链表结合。在1.8后还加入了红黑树结构。初始容量为16,填充因子默认为0.75，扩容时是当前容量的翻倍。

HashTable基于Map接口和Dictionary类；线程安全，开销比HashMap大，如果多线程访问一个Map对象，使用HashTable更好；不允许使用null为key和value；底层是基于哈希表的结构。初始容量为11，填充因子默认为0.75，扩容时容量翻倍+1

### HashMap在put、get元素的过程？体现了什么的数据结构？

* 向HashMap中put元素时，首先判断key是否为空，为空则直接调用putForNullKey(),不为空则计算key的hash值得到该元素的下标值，如果在该位置没有位置处没有元素，就直接保存；如果有，还要比较是否存在相同的key，存在的话就覆盖原来key的value，否则将该元素保存在链头，先保存的在链尾。

* 从Hashmap中get元素时，计算key的hash值找到在数组中的对应的下标值，返回该key对应的value即可，如果有冲突就遍历该位置链表寻找key相同的元素并返回对应的value

### 如何解决hash冲突

* 开放定址法：常见的线性探测方式，在冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表

* 链地址法：将有冲突数组位置生出链表

* 建立公共溢出区：将哈希表分为基本表和逸出表两部分两部分，和基本表发生冲突的元素一律填入逸出表

* 再哈希表：构造多个不同的hash函数，有冲突使用下一个哈希函数计算哈希值


### 注解级别

源码级别：注解将被编译器丢弃（该类型的注解信息只会保留在源码里，源码经过编译后，注解信息会被丢弃，不会保留在编译好的class文件里）

class文件级别：注解在class文件中可用，但会被VM丢弃。但可以用于生成代码。如apt。ARutuer里面有所应用

运行时注解：代码在运行时也有用，常用于自动注入。

### JVM中如何判断一个类 

在运行时，一个类和接口并不是单单由它的名称决定。而是由它的二进制名称与定义类的加载器共同确定。