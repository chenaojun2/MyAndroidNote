# JAVA并发

## 线程的使用

使用线程的四种方式

- 继承Thread
- 实现Runnable接口
- 实现Callable接口
- 使用线程池

注意 
- 实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，最后还需要通过 Thread 来调用。
- Callable 与 Runnable接口的区别在于 Callable接口有返回值。 

## 实现接口VS继承Thread

开发中更多的是选择实现接口的方式使用线程，理由如下

- java不支持多人继承，所以继承了Thread就不能继承其他类，十分不利于扩展。
- 实现类的话可能要求只执行就行，继承整个类的开销过大。

## 线程安全

什么是线程安全，线程并发安全的本质是让我们并行的线程，有序的运行，一个线程的执行结果，对其他线程可见。

在开发中需要保证线程安全则需要灵活运用锁，锁的分类如下。

### 锁分类

#### 线程是否需要锁住同步资源

锁住：悲观锁 snychronized,ReentrantLock

不锁住：乐观锁 原子类 AtomicInteger

#### 锁住同步资源失败，要不要阻塞

阻塞：阻塞锁  snychronized,ReentrantLock

不阻塞：自旋锁  原子类 AtomicInteger

#### 获取锁资源时需不需要排队

排队：公平锁  ReentrantLock

不排队：非公平锁  ReentrantLock snychronized

#### 一个线程的多个流程可不可以获取同一个锁

可以：可重入锁  ReentrantLock snychronized

不可以：不可重入锁

#### 多个线程共享一把锁

能：共享锁 ReadLock

不能：排他锁 WriteLock

#### 多线程竞争同步资源

不锁柱资源，多个线程中只有一个能修改成功，其他会重试  ： 无锁

同一线程执行同步资源时自动获取锁  ： 偏向锁

多个线程竞争时，没有获取到资源的线程自选等待  ： 轻量级锁

多个线程竞争时，没有获取到资源的线程被阻塞等待唤醒  ： 重量级锁

____那么如何运用这些锁呢____

#### 锁的浅要解析

____AtomicInteger____ : 原子包装类，自旋的设计能够有效避免线程因为阻塞-唤醒带来的系统开销。

适用场景：多线程计数，原子操作，并发数量小的情况

____volatile____ : 可见性修饰。被修饰的变量被修改时，会强迫将变化的值写入共享内存，其他线程也可见。

但不能解决非原子类操作带来的问题。

非原子类操作 count++ 、count = count + 1

____snychronized____ : snychronized的使用则分为 锁对象、锁class对象、锁代码块。

- 锁方法  ——锁在对象上，未获取到对象锁的其他线程都不可以访问该方法。

- 锁class ——锁住类对象，不同的对象实例也能保证线程安全。


- 锁代码块 ——为获取对象锁的，可以执行代码块外的代码。

snychronized的优势在于基于jvm目前优化的很好了，可以自动释放锁，规避死锁

劣势在于 不能中途释放锁。 不能知道获取锁是否成功，不够灵活。

____snychronized优化后的锁的膨胀流程____

锁的膨胀流程为： 偏向锁->轻量级锁->重量级锁

其中偏向锁和轻量级锁属于乐观锁

重量锁属于悲观锁

当一个对象刚实例化的时候，当前没有任何线程访问它的时候是可偏向的。当有第一个线程访问的时候就会偏向这个线程。这个线程在修改对象头成为偏向锁的时候使用CAS操作，并将对象头中的ThreadID改成自己的ID，之后再次访问这个对象时，只需要对比ID，不需要再使用CAS在进行操作。

一旦有第二个线程访问对象，此时偏向锁不会主动释放，第二个线程可以看到当前的对象是偏向锁状态，这时就表明这份对象上是有竞争的。检查持有该对象的锁是否依然存活，如果发现持有线程挂了就重新置为为无锁状态，然后重新偏向新线程。如果线程存活，则马上执行那个线程的操作栈，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁，（偏向锁就是这个时候升级为轻量级锁的）

轻量级锁是认为存在竞争的，但是竞争的程度很轻。一般两个线程对于同一个锁的操作都会错开，或者稍微等待（自旋），另一个线程就会释放锁。但是当自旋超过一定次数或者第三个线程出现参与竞争，就会膨胀成重量级锁。


____ReentrantLock____ : 

ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。 默认非公平锁可以设置为公平锁，同时是可重入锁、阻塞锁、悲观锁。除此之外ReentrantLock的高级功能相当多，如分组加锁等等。

#### 正确使用锁

- 减少锁的持有时间，有些代码块是不必要加锁的就不加锁

- 锁分离，将读写分离，只在写锁进入才做同步

- 锁粗化，将多次加锁，解锁合并在一起。


## 线程池

### 线程池的任务提交流程

提交任务

- 已创建线程 < 核心线程数 ---> addWorker()

- 已创建线程 > 核心线程数 ---> 等待队列是否已满


- 等待队列未满 --->  加入等待队列

- 等待队列未满 --->  已创建线程 > 最大线程数 ？

- 已创建线程 > 最大线程数 ---> 拒绝策略

- 已创建线程 < 最大线程数 ---> addWorker()

addWorker方法流程

1、检查状态是否能创建线程

2、把runnable封装成worker，添加到工作队列

3、启动新建的线程

4、runWorker 开启循环，执行任务。执行完任务检查等待队列是否有任务有就进行服用

线程池的拒绝策略

1、AbortPolicy :直接报异常

2、DiscardPolicy：丢弃任务

3、DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务

4、CallerRunsPolicy：由调用线程（提交任务的线程）处理该任务