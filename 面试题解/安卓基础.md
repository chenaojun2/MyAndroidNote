# 安卓基础

## Activty

### Activty生命周期
* onCreate()表示Activity 正在创建，常做初始化工作，如setContentView界面资源、初始化数据
* onStart()表示Activity 正在启动，这时Activity 可见但不在前台，无法和用户交互
* onResume()表示Activity 获得焦点，此时Activity 可见且在前台并开始活动
* onPause()表示Activity 正在停止，可做 数据存储、停止动画等操作
* onStop()表示activity 即将停止，可做稍微重量级回收工作，如取消网络连接、注销广播接收器等
* onDestroy()表示Activity 即将销毁，常做回收工作、资源释放
另外，当Activity由后台切换到前台，由不可见到可见时会调用onRestart()，表示Activity 重新启动


### onStart()和onResume()/onPause()和onStop()的区别？

onStart()与onStop()是从Activity是否可见这个角度调用的，onResume()和onPause()是从Activity是否显示在前台这个角度来回调的，在实际用中差别不大。注意当有Activity做的弹窗出现时，会调用onPause() 而不会 onStop()

### Activity A启动另一个Activity B会回调哪些方法？如果Activity B是完全透明呢？如果启动的是一个对话框Activity呢？

Activity A启动另一个Activity B会回调的方法：Activity A的onPause() -->Activity B的onCreate()-->onStart()-->onResume()-->Activity A的onStop()；如果Activity B是完全透明的，则最后不会调用Activity A的onStop()；如果是对话框Activity，同后种情况。


### 谈谈onSaveInstanceState()方法？何时会调用？

当非人为终止Activity时，比如系统配置发生改变、横竖屏切换时导致Activity被杀死并重新创建、资源内存不足导致低优先级的Activity被杀死，会调用 onSavaInstanceState() 来保存状态。该方法调用在onStop之前，但与onPause没有时序关系。

### onSaveInstanceState()与onPause()的区别？

onSaveInstanceState()适用于对临时性状态的保存，而onPause()适用于对数据的持久化保存。

### 如何避免配置改变时Activity重建？

指定configChanges属性，重写onConfigurationChanged方法即可。

### 优先级低的Activity在内存不足被回收后怎样做可以恢复到销毁前状态？

先级低的Activity在内存不足被回收后重新打开会引发Activity重建。Activity被重新创建时会调用onRestoreInstanceState（该方法在onStart之后），并将onSavaInstanceState保存的Bundle对象作为参数传到onRestoreInstanceState与onCreate方法。因此可通过onRestoreInstanceState(Bundle savedInstanceState)和onCreate((Bundle savedInstanceState)来判断Activity是否被重建，并取出数据进行恢复。但需要注意的是，在onCreate取出数据时一定要先判断savedInstanceState是否为空。另外，谷歌更推荐使用onRestoreInstanceState进行数据恢复。


### 说下Activity的四种启动模式？

* standard标准模式：每次启动一个Activity就会创建一个新的实例
* singleTop栈顶复用模式：如果新Activity已经位于任务栈的栈顶，就不会重新创建，并回调 onNewIntent(intent) 方法。常用于防止重复点击。
* singleTask栈内复用模式：只要该Activity在一个任务栈中存在，都不会重新创建，并回调 onNewIntent(intent) 方法。如果不存在，系统会先寻找是否存在需要的栈，如果不存在该栈，就创建一个任务栈，并把该Activity放进去；如果存在，就会创建到已经存在的栈中。常用于主页
* singleInstance单实例模式：具有此模式的Activity只能单独位于一个任务栈中，且此任务栈中只有唯一一个实例。可以用作闹钟等应用。


### Activity的启动过程？

调用startActivity()后经过重重方法会转移到ActivityManagerService的startActivity()，并通过一个IPC回到ActivityThread的内部类ApplicationThread中，并调用其scheduleLaunchActivity()将启动Activity的消息发送并交由Handler H处理。Handler H对消息的处理会调用handleLaunchActivity()->performLaunchActivity()得以完成Activity对象的创建和启动。


## Fragment

### 谈一谈Fragment的生命周期？

onAttach()->onCreate()-> onCreateView()->onActivityCreated()->onStart()->onResume()->onPause()->onStop()->onDestroyView()->onDestroy()->onDetach()

* onAttach()：当Fragment和Activity建立关联时调用
* onCreateView()：当Fragment创建视图时调用
* onActivityCreated()：当与Fragment相关联的Activity完成onCreate()之后调用
* onDestroyView()：在Fragment中的布局被移除时调用
* onDetach()：当Fragment和Activity解除关联时调用

### Activity和Fragment的异同？

* Activity和Fragment的相似点在于，它们都可包含布局、可有自己的生命周期，Fragment可看似迷你活动。
* 不同点是，由于Fragment是依附在Activity上的，多了些和宿主Activity相关的生命周期方法，如onAttach()、onActivityCreated()、onDetach()；另外，Fragment的生命周期方法是由宿主Activity而不是操作系统调用的，Activity中生命周期方法都是protected，而Fragment都是public，也能印证了这一点，因为Activity需要调用Fragment那些方法并管理它。

### Activity和Fragment的关系？

* 正如Fragment的名字“碎片”，它的出现是为了解决Android碎片化 ，它可作为Activity界面的组成部分，可在Activity运行中实现动态地加入、移除和交换。
* 一个Activity中可同时出现多个Fragment，一个Fragment也可在多个Activity中使用。
* 另外，Activity的FragmentManager负责调用队列中Fragment的生命周期方法，只要Fragment的状态与Activity的状态保持了同步，宿主Activity的FragmentManager便会继续调用其他生命周期方法以继续保持Fragment与Activity的状态一致。

### 何时会考虑使用Fragment?

非常经典的例子，即用两个Fragment封装两个界面模块，这样只使一套代码就能适配两种设备，达到两种界面效果；单一场景切换时使用Fragment更轻量化，如ViewPager和Fragment搭配使用在主页做tab
